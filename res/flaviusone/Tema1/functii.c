/**
 * Tema 1 SO - Hashtable
 *
 * Copyright (C) 2014, Flavius Tirnacop 331CA <flavius.tirnacop@cti.pub.ro>
 *
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 *
 */

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "debug.h"
#include "utils.h"
#include "functii.h"


/**
 * Allocate memory for hashtable
 */
Hashtable *create_Hashtable(unsigned int size){
	Hashtable *hash;
	unsigned int i;

	DIE(size<1,"Invalid size");

	/* Allocate memory for whole hashtable */
	hash = malloc(sizeof(Hashtable));
	if(hash == NULL)  return NULL;

	/* Allocate memory for the buckets */
	hash->buckets = calloc(size,sizeof(Nod*));
	if(hash->buckets == NULL)  return NULL;

	/* Allocated initial nodes */
	for(i = 0 ; i < size ; i++){
		hash->buckets[i] = NULL;
	}

	hash->size = size;

	return hash;
}

/**
 * Adds a specified word into the hashtable
 * at a key generated by hash_function
 */
int Hash_add(char* word,Hashtable* hash){
	Nod *nod_nou,*nod;
	/* This is the previous node */
	Nod *nod_aux = NULL;
	unsigned int index;
	char *d;
	/* Compute hash index */
	index = hash_function(word,hash->size);
	dprintf("Added word %s has bucket index %u\n",word, index);



	nod_nou = malloc(sizeof(Nod));
	/* Check if allocate did succede */
	if(nod_nou == NULL) return -1;
	nod_nou->next = NULL;

	/* Add string to Node */
	d = malloc (strlen (word) + 1);   // Space for length plus nul
	if (d == NULL) return -1;          // No memory
	strcpy (d,word);
	nod_nou->cuvant = d;

	/* Get Node bucket */
	nod = hash->buckets[index];

	/* If first element add it and end*/
	if(nod == NULL){
		hash->buckets[index] = nod_nou;
		return 1;
	}

	/* Check for duplicates */
	while(nod != NULL){
		if(strcmp(word,nod->cuvant) == 0){
			/* Word already exists */
			return 2;
		}
		nod_aux = nod;
		nod = nod->next;
	}

	/* Add new node to the end of list */
	if(nod_aux != NULL){
		nod_aux->next = nod_nou;
	}else{
		hash->buckets[index] = nod_nou;
	}

	return 1;
}
/**
 * Removes word from hashtable
 * Returns 1 if success -1 on fail
 */
int Hash_remove(char* word,Hashtable* hash){
	/* Compute Index */
	unsigned int index = hash_function(word,hash->size);

	Nod* nod = hash->buckets[index];
	Nod* nod_aux = NULL;
	/* Check if bucket has elements */
	if(nod == NULL) return -1;

	/* Search for Word to remove */
	while(nod != NULL){
		if(strcmp(nod->cuvant,word) == 0){
			free(nod->cuvant);
			if(nod_aux != NULL){
				nod_aux->next = nod->next;
			}else{
				/* first element */
				hash->buckets[index] = nod->next;
			}
			free(nod);

			return 1;
		}
		nod_aux = nod;
		nod = nod->next;
	}
	/* Word was not found */
	return -1;
}
/**
 * Clears Hashtable
 */
int Hash_clear(Hashtable* hash){
	unsigned int i;
	Nod *nod,*tmp;
	for(i = 0; i<hash->size ; i++){
		nod = hash->buckets[i];
		/* Free each bucket */
		while(nod != NULL){
			tmp = nod;
			nod = nod ->next;
			tmp->next = NULL;
			free(tmp->cuvant);
			free(tmp);
			tmp = NULL;
		}
		hash->buckets[i] = NULL;
	}
	return 1;
}

/**
 * Searches for a word in the hashtable
 * If file is provided prints True/False
 * If file is not provided prints True/False at console (stdout)
 */
int Hash_find(char* word,char* outfile,Hashtable* hash){
	FILE* g;
	/* Compute Index */
	unsigned int index = hash_function(word,hash->size);
	int found = 0;
	Nod* nod = hash->buckets[index];

	/* Search trough Node list at entry index */
	while(nod != NULL){
		if(strcmp(nod->cuvant,word) == 0){
			found = 1;
		}
		nod = nod->next;
	}

	/* Check if NO file was supplied */
	if(outfile == NULL)
		if(found)
			printf("True\n");
		else
			printf("False\n");
	else{
		/* Open file in append mode */
		g = fopen(outfile,"a");
		DIE(g<0,"Error in Opening file (Hash_find)");
		if(found)
			fprintf(g,"True\n");
		else
			fprintf(g,"False\n");
		fclose(g);
	}
	return 1;
}

/**
 * Prints index bucket at STDOUT or in FILE
 */
int Hash_print_bucket(unsigned int index, char* outfile,Hashtable* hash){

	FILE* g;
	Nod *nod;
	nod = hash->buckets[index];

	/* Open file for writing */
	if(outfile != NULL){
		g = fopen(outfile, "a");
	}
	if(nod == NULL) return 1;
	while(nod != NULL){
		if(outfile == NULL){
			printf("%s ",nod->cuvant);
		}else{
			fprintf(g,"%s ",nod->cuvant);
		}
		nod = nod->next;
	}

	/* Print \n and close file */
	if(outfile == NULL){
			printf("\n");
	}else{
			fprintf(g,"\n");
			fclose(g);
	}
	return 1;
}

/**
 * Prints whole hashtable at STDOUT or in FILE
 * We don't use print_bucket because that woudl mean opening and closing
 * the file too many times
 */
int Hash_print(char* outfile,Hashtable* hash){

	FILE* g;
	Nod *nod;
	unsigned int i;

	/* Open file for writing */
	if(outfile != NULL){
		g = fopen(outfile, "a");
	}

	for(i = 0 ; i < hash->size ; i++){
		nod = hash->buckets[i];
		/* Skip empty buckets */
		if(nod == NULL) continue;
		while(nod != NULL){
			if(outfile == NULL){
				printf("%s ",nod->cuvant);
			}else{
				fprintf(g,"%s ",nod->cuvant);
			}
			nod = nod->next;
		}

		/* Print \n and close file */
		if(outfile == NULL){
				printf("\n");
		}else{
				fprintf(g,"\n");
		}
	}
	/* Close file if opened */
	if(outfile != NULL) fclose(g);

	return 1;
}
/**
 * Creates a new hashtable with size doubled and adds the data from
 * the initial hashtable
 */
int Hash_resize_double(Hashtable* hash){
	Hashtable* new_hash;
	Nod* nod;
	unsigned int i;
	int res;

	/* Compute new size */
	unsigned int new_size = hash->size * 2;

	/* Allocate new hash */
	new_hash = create_Hashtable(new_size);
	DIE(new_hash==NULL,"Unable to allocate");

	/* Iterate trough old hash and add at new hash */
	for(i = 0 ; i < hash->size ; i++){
		nod = hash->buckets[i];
		while(nod != NULL){
			res = Hash_add(nod->cuvant,new_hash);
			DIE(res<0,"Error in Hash_add");
			nod = nod -> next;
		}
	}
	/* Free Old Hash */
	res = Hash_clear(hash);
	DIE(res < 0,"Error in hash_clear");
	free(hash->buckets);


	/* Restore pointers*/
	hash->size = new_hash->size;
	hash->buckets = new_hash->buckets;

	return 1;
}

/**
 * Creates a new hashtable with size halved and adds the data from
 * the initial hashtable
 */
int Hash_resize_halve(Hashtable* hash){
	Hashtable* new_hash;
	Nod* nod;
	unsigned int i,res;

	/* Compute new size */
	unsigned int new_size = hash->size / 2;

	/* Allocate new hash */
	new_hash = create_Hashtable(new_size);
	DIE(new_hash==NULL,"Unable to allocate");

	/* Iterate trough old hash and add at new hash */
	for(i = 0 ; i < hash->size ; i++){
		nod = hash->buckets[i];
		while(nod != NULL){
			res = Hash_add(nod->cuvant,new_hash);
			DIE(res<0,"Error in Hash_add");
			nod = nod -> next;
		}
	}
	/* Free Old Hash */
	res = Hash_clear(hash);
	DIE(res < 0,"Error in hash_clear");
	free(hash->buckets);

	/* Restore pointers*/
	hash->size = new_hash->size;
	hash->buckets = new_hash->buckets;

	return 1;
}

/**
 * Functie de hash bazata pe djb2 a lui Dan Bernstein
 * http://www.cse.yorku.ca/~oz/hash.html
 * @return valoarea de dispersie (cheia)
 */
unsigned int hash_function(const char *str, unsigned int hash_length)
{
	unsigned int hash = 5381;
	int c;

	while ( (c = *str++) != 0 )
		hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

	return (hash % hash_length);
}

